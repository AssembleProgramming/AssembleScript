$=====================================================================================
                            SELF TEST IMPLEMENTATION
======================================================================================$
# This file contains the implementations and test cases for the current functionality of 
# AssembleScript. Write to this file is strictly prohibited
#                         ❌ DO NOT EDIT THIS FILE ❌

$=====================================================================================
                        Factorial calculation using recursion
======================================================================================$
assemble factorial_recursive(n) {
  ifWorthy(n == 0 || n == 1) {
    snap 1;
  }
  snap n * factorial_recursive(n - 1);
}

# Test case for factorial_recursive
assemble test_factorial_recursive() {
  vision("Testing factorial_recursive...");
  assertEqual(factorial_recursive(0), 1);
  assertEqual(factorial_recursive(1), 1);
  assertEqual(factorial_recursive(5), 120);
  assertEqual(factorial_recursive(10), 3628800);
  vision(" ");
}

$=====================================================================================
                            Factorial calculation using Loop
======================================================================================$
assemble factorial_loop(n) {
  ifWorthy(n == 0 || n == 1){
    snap 1;
  }
  newAvenger result = 1;
  wakandaForEach(i in 1 to n) {
    result = result * i;
  }
  snap result;
}

# Test case for factorial_loop
assemble test_factorial_loop() {
  vision("Testing factorial_loop...");
  assertEqual(factorial_loop(0), 1);
  assertEqual(factorial_loop(1), 1);
  assertEqual(factorial_loop(5), 120);
  assertEqual(factorial_loop(10), 3628800);
  vision(" ");
}

$=====================================================================================
                Check if a number is prime using the Sieve of Eratosthenes
======================================================================================$
assemble is_prime_sieve(n) {
  ifWorthy(n <= 1) {
    snap HYDRA;
  }
  team sieve[n+1] = {SHIELD};
  sieve[0] = HYDRA;
  sieve[1] = HYDRA;

  wakandaForEach(idx in 2 to n step 1){
    sieve[idx] = SHIELD;
  }
  newAvenger i = 2;
  fightUntil(i * i <= n){
    ifWorthy(sieve[i]){
      newAvenger j = i * i;
      fightUntil(j <= n){
        sieve[j] = HYDRA;
        j = j + i;
      }
    }
    i = i + 1;
  }

  snap sieve[n];
}

# Test case for is_prime_sieve
assemble test_is_prime_sieve() {
  vision("Testing is_prime_sieve...");
  assertEqual(is_prime_sieve(2), SHIELD);
  assertEqual(is_prime_sieve(3), SHIELD);
  assertEqual(is_prime_sieve(4), HYDRA);
  assertEqual(is_prime_sieve(17), SHIELD);
  assertEqual(is_prime_sieve(25), HYDRA);
  vision(" ");
}


$=====================================================================================
                            Nested for loops
======================================================================================$
assemble nested_for_test() {
  vision("Testing nested_for_test...");
  newAvenger sum = 0;
  wakandaForEach(i in 1 to 2) {
    wakandaForEach(j in 1 to 2) {
      sum = sum + (i * j);
    }
  }
  assertEqual(sum, 9); 
  vision(" ");
}

$=====================================================================================
                        Factorial calculation using recursion
======================================================================================$
assemble reverse_int(num){
    ifWorthy(num <= 0){
        snap num;
    }
    newAvenger ans = 0;
    fightUntil(num > 0){
        newAvenger lastDigit = num % 10;
        ans = ans * 10 + lastDigit; 
        num = floor(num / 10);
    }
    snap ans;
}
# Test case for reverse_int
assemble test_reverse_int(){
    vision("Testing reverse_int...");
    assertEqual(reverse_int(131), 131);
    assertEqual(reverse_int(123), 321);
    assertEqual(reverse_int(0), 0);
    assertEqual(reverse_int(111), 111);
    assertEqual(reverse_int(9), 9);
    assertEqual(reverse_int(<MINUS>1), <MINUS>1);
    assertEqual(reverse_int(1734), 4371);
    vision(" ");
}

$=====================================================================================
                        Binary search Iterative
======================================================================================$
assemble binary_search(arr, n, key){
    newAvenger lo = 0;
    newAvenger hi = n-1;

    fightUntil(lo <= hi){
        newAvenger mid = floor(lo + (hi - lo)/2);
        ifWorthy(arr[mid] ==  key){
            snap SHIELD;
        }
        otherwise ifWorthy(arr[mid] >  key){
            hi = mid - 1;
        }
        otherwise{
            lo = mid + 1;
        }
    }
    snap HYDRA;
}
# Test case for binary_search
assemble test_binary_search(){
    team arr_zero[1] = {1};
    newAvenger size_zero = 1;

    team arr_one[7] = {1,2,3,4,5,6,7};
    newAvenger size_one = 7;

    team arr_two[6] = {1,2,3,4,5,6};
    newAvenger size_two = 6;

    team arr_three[3] = {1,2,3};
    newAvenger size_three = 3;

    team arr_four[1] = {1};
    newAvenger size_four = 1;

    vision("Testing reverse_int...");
    assertEqual(binary_search(arr_zero, size_zero, 1), SHIELD);
    assertEqual(binary_search(arr_one, size_one, 4), SHIELD);
    assertEqual(binary_search(arr_two, size_two, 8), HYDRA);
    assertEqual(binary_search(arr_three, size_three, 50), HYDRA);
    assertEqual(binary_search(arr_four, size_four, 1), SHIELD);

    vision(" ");
}
$=====================================================================================
                        Binary search Recursive
======================================================================================$

assemble recursiveBinarySearchFunction(arr, x,start, end){
    ifWorthy(start > end) 
    {
        snap HYDRA;
    }
    newAvenger mid = floor((start + end) / 2);

    ifWorthy(arr[mid] == x){
        snap SHIELD;
    }

    ifWorthy(arr[mid] > x) 
    {
        
        snap recursiveBinarySearchFunction(arr, x, start, mid - 1);
    }
    otherwise{ 
        snap recursiveBinarySearchFunction(arr, x, mid + 1, end);
    }
}



assemble test_recursive_binary_code() {
  team arr[6] = {1, 3, 5, 7, 8, 9};
  vision("Testing Binary search recurssive");
  assertEqual(recursiveBinarySearchFunction(arr,5,0,5), SHIELD);
  assertEqual(recursiveBinarySearchFunction(arr,9,0,5), SHIELD);
  assertEqual(recursiveBinarySearchFunction(arr,0,0,5), HYDRA);
  assertEqual(recursiveBinarySearchFunction(arr,3,0,5), SHIELD);
  assertEqual(recursiveBinarySearchFunction(arr,100,0,5), HYDRA);
  vision(" ");
}


$ ==========================================================================
                            Variable Declaration 
========================================================================== $
assemble test_declare_var(){
    vision("Testing Variable Declaration...");
    newAvenger a = 10;
    newEternal b = 11;
    assertEqual(a, 10);
    assertEqual(b, 11);
    vision(" ");
}
$ ==========================================================================
                            fightUntil Loop
========================================================================== $
assemble test_fightUntil_loop(){
    vision("Testing Break In fightUntil loop...");
    newAvenger i = 0;
    fightUntil(i < 10){
        ifWorthy(i == 8){
            endGame;
        }
        i = i + 1;
    }
    assertEqual(i,8);
    vision(" ");
}
$ ==========================================================================
                            Wakanda for Loops
========================================================================== $
assemble test_for_loop(){
    vision("Testing Break In FOR loop...");
    newAvenger i = 0;
    wakandaFor(i ; i < 10; i = i + 1){
        ifWorthy(i == 8){
            endGame;
        }
        i = i + 1;
    }
    assertEqual(i,8);
    vision(" ");
}
$ ==========================================================================
                            Nested Teams
========================================================================== $
assemble test_nested_teams(){
    vision("Testing Nested Teams...");
    newAvenger str = "Loki";
    team apk[1] = {str};
    team arr[1] = {apk};
    wakandaForEach(i in 0 to 0){
        wakandaForEach(j in 0 to 0){
            assertEqual(arr[i][j], "Loki");
            vision(" ");
            snap;
        }
    }
}
$ ==========================================================================
                            String
========================================================================== $
assemble test_string(){
    vision("Testing String Arithmetic...");
    newEternal string = "12";
    newEternal s = 3;

    newAvenger resStrAdd = string + s;
    newAvenger resStrMul = string*s;
    newAvenger resStrMul_ = s * string;

    assertEqual(resStrAdd, "123");
    assertEqual(resStrMul, "121212");
    assertEqual(resStrMul_, "121212");

    newAvenger numstr = parseInt(string);
    newAvenger nums = parseInt(s);

    assertEqual(numstr + nums, 15);
    assertEqual(numstr * nums, 36);

    assertEqual(string, "12");
    vision(" ");
}
$ ==========================================================================
                            Nums
========================================================================== $
assemble test_nums(){
    vision("Testing Number Arithmetic...");
    newAvenger n = 2;
    newAvenger m = 10;

    assertEqual(n ^ m, 1024);
    assertEqual(pow(n, m), 1024);
    vision(" ");
}
$ ==========================================================================
                            ifWorthy-CHAIN
========================================================================== $
assemble test_ifWorthy_chain(){
    vision("Testing ifWorthy-CHAIN...");
    newAvenger name = "Shashank";
    ifWorthy(name[0] == "S"){
        ifWorthy(name[1] == "h"){
            ifWorthy(name[2] == "a"){
                ifWorthy(name[3] == "s"){
                    ifWorthy(name[4] == "h"){
                        ifWorthy(name[5] == "a"){
                            ifWorthy(name[6] == "n"){
                                ifWorthy(name[7] == "k"){
                                    assertEqual("HI", "HI");
                                    vision(" ");
                                    snap;
                                } 
                            } 
                        } 
                    } 
                    vision("❌ You should never reach here!!!");
                } 
            } 
        }   
    }
}

$ ==========================================================================
                            Teams
========================================================================== $
assemble test_teams(){
    vision("Testing teams...");
    team avengers[4]= {"Captain America", "Iron Man", "Thor", "Hulk"};

    newAvenger firstAvenger = avengers[0];
    newAvenger secondAvenger = avengers[1];

    assertEqual(firstAvenger, "Captain America");
    assertEqual(secondAvenger, "Iron Man");


    team male[10] = {"Captain America", "Iron Man" ,"Dr. Strange", "Hulk", "Hawkeye", "Spiderman", "Thor", "T`Challa", "Ant Man", "Moon Knight"};
    team female[7]= {"Black Widow","Captain Marvel","Wanda Maximoff","She Hulk","Ms Marvel","Gamora","Nebula"};
    team avenger[2]= {male, female};

    assertEqual(avenger[0][4], "Hawkeye");
    assertEqual(avenger[1][6], "Nebula");

    vision(" ");
}
$ ==========================================================================
                            User Defined Functions
========================================================================== $
assemble test_user_defined_twopointo(){
    vision("Testing User Defined Functions...");
    assemble f(){
        snap ("Called f");
    }
    assemble f_(){
        snap ("Called f_");
    }
    team functions[2] = {f(), f_};
    assertEqual(functions[1](),"Called f_");

    assemble testFunction(){
        ifWorthy(HYDRA){
            ifWorthy(HYDRA){
                snap 10;
            }
            otherwise{
                ifWorthy(HYDRA){
                    snap 20;
                }
                otherwise{
                    ifWorthy(HYDRA){
                        snap 30;
                    }
                    otherwise{
                        snap 11;
                    }
                }
            }
        }
        otherwise ifWorthy(SHIELD){
            ifWorthy(HYDRA){
                snap 100;
            }
            otherwise{
                ifWorthy(HYDRA){
                    snap 200;
                }
                otherwise{
                    ifWorthy(HYDRA){
                        snap 300;
                    }
                    otherwise{
                        snap 1000;
                        vision("❌ You should never reach here!!!");
                        
                    }

                }
                vision("❌ You should never reach here!!!");
            }
        }
        otherwise{
            snap 21;
        }
    }
    assemble main(){
        assertEqual(testFunction(), 1000);
    }

    main();
    vision(" ");
}

$ ==========================================================================
                            Snap in switch
========================================================================== $
assemble test_snap_in_switch(){
    vision("Testing User Defined Functions in Switch...");
    assemble switchTest(c){
        multiverse(c){
            madness 0:
                snap "Case 0";
            madness 1:
                snap "Case 1";
            madness 2:
                snap "Case 2";
            madness 3:
                snap "Case 3";
            default:
                snap "Default";
        }
    }
    vision(typeOf(switchTest(0)));
    assertEqual(switchTest(0), "Case 0");
    assemble stringSwitchTest(c){
        multiverse(c){
            madness "one":
                snap "String Case 1";
            madness "two":
                snap "String Case 2";
            madness "three":
                snap "String Case 3";
            madness "four":
                snap "String Case 4";
            default:
                snap "String Case Default";
        }
    }

    assertEqual(stringSwitchTest("one"), "String Case 1");
    vision(" ");
}

$ ==========================================================================
                            Snap in fightUntil loop
========================================================================== $
assemble test_snap_in_fightUntil_loop(){
    vision("Testing snap in while loop...");
    team testArray[6] = {11,13,17,19,23,27};
    team testArray_[6] = {11,13,17,20,23,27};
    assemble isEvenPresent(arr){
        newAvenger idx = 0;
        fightUntil(idx < 6){
            ifWorthy(arr[idx] % 2 == 0){
                snap SHIELD;
            }
            idx = idx + 1;
        }
        snap HYDRA;
    }

    assertEqual(isEvenPresent(testArray), HYDRA);
    assertEqual(isEvenPresent(testArray_), SHIELD);

}


$=====================================================================================
                            Run all the test cases
======================================================================================$
assemble run_tests() {
  test_factorial_recursive();
  test_factorial_loop();
  test_is_prime_sieve();
  nested_for_test();
  test_reverse_int();
  test_binary_search();
  test_recursive_binary_code();
  test_declare_var();
  test_fightUntil_loop();
  test_for_loop();
  test_nested_teams();
  test_string();
  test_nums();
  test_ifWorthy_chain();
  test_teams();
  test_user_defined_twopointo();
  test_snap_in_switch();
  test_snap_in_fightUntil_loop();
}

run_tests();